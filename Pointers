#Pointers

- Quando se fala de memória, contexto de C, lembre da RAM;
- Cada byte da memória tem um endereço;
- Na declaração de uma variável, memória é alocada. A quantidade depende do tipo;
- O computador, internamente, tem uma "lookup table" que guarda as informações (tipo, local, existência) da variável;
- Quando uma operação com uma variável é feita, o computador (compilador?) acessa essa lookup table para verificar o endereço da variável e lê-lo (read) ou alterá-lo (write);
(nota: um identificador (indentifier) NÃO ocupa lugar de memória na RAM, apenas o valor ao qual está associado o faz.
*PONTEIROS: São variáveis que armazenam o endereço memória de outra variável;

EXEMPLO(pseudocodigo):
int a; (suponha endereço 204)
int *p; (declaração) (suponha endereço 64)
p = &a; (referencing)
a = 5;
print p; // 204
print &a; //204
print a; //5
print &p; //64
print *p; //5 (dereferencing)
*p = 8;
print a; //8

p --> address
*p --> value at addr ess

dereference --> access/modify value
(perceba que um ponteiro também ocupa lugar na memória, logo tem um endereço. Pode ser referenciado?)

TIPOS:
int *a;
char *c;
float *f;
double *lf;
user defined types (classes(c++) e struct)
(notas: Quando se fala que um ponteiro p aponta para o endereço de uma variável, realmente existe uma ligação do computador de  uma variável a outra? Ou
p só faz armezanar o endereço e "apontar" é "modo de falar"? Por que é necessário definir o tipo "ponteiro" se um int poderia armazenar 
um número relacionado a memória? (tem a ver com a possível existencia dessa ligação intrinsica? ou é apenas porque as operações de ponteiros
são distintas de int e precisam ser bem definidas com um novo tipo(seria possivel ser distinto?) Qual a necessidade de ponteiros terem tipos? Seus tamanhos não são necessariamente iguais?
Definem, de novo, outras operações distintas pelo tipo? Ou tem relação com o tamanho distintos dos tipos? De fato, lembre-se que não só lugar da memória é contralado pelo ponteiro, isto é, mais de um byte)


Motivação para ponteiros serem strongly typed: A função de um ponteiro não é unicamente guardar um valor da memória. Também é possível acessar o dado associado aquele local através de um porcesso chamado 
derreferência (dereference). Para lê-lo da maneira correta e operá-lo, precisa saber de qual tipo ele é, pois, a depender do tipo, variáveis podem ter tamanhos (em bytes) distintos e a informação ser codificada
de maneira distinta para esses bytes. Suponha ponteiros *f e *i (float e int, respectivamente). Se apontam variáveis de seus repectivos tipos e que carregam a mesma informação binária, ainda assim, seu significado
na derreferência seria distinto. 

VEJA:
void pointers --> Não podem ser derreferenciados, também não sofre operações aritméticas. Em virtude que não possuem um tipo associado, não é possível saber o tamanho de bytes para derreferenciação (escrita e leitura),
não é possível saber de que forma os bits são codificados, não é possível prosseguir e alcançar o "próximo" tipos da memória.

CASTING:
// char unsigned *c = (char unsigned*)&a; //Typecasting
// char unsigned *c = (char*)&a; //Typecasting
//char *c = (char unsigned*)&a; //Typecasting
// char *c = (char*)&a; //Typecasting
São possíveis! Existem motivos e implicações disso.


Notas de conteúdos futuros:
- LEIA: https://www.alura.com.br/artigos/garbage-collector#:~:text=%C3%A9%20Garbage%20Collector?-,A%20Garbage%20Collector%20(ou%20coletor%20de%20lixo)%20%C3%A9%20um%20mecanismo,que%20n%C3%A3o%20est%C3%A1%20sendo%20utilizado.
- lookup table
- escopo, variáveis globais e divisão da memória pelo compilador
- array e função
